---
id: 622
title: 함수를 정의하자.
date: 2016-02-18T02:04:03+00:00
author: Burt
layout: post
guid: http://blog.burt.pe.kr/?p=622
permalink: '/%ed%95%a8%ec%88%98%eb%a5%bc-%ec%a0%95%ec%9d%98%ed%95%98%ec%9e%90/'
dsq_thread_id:
  - "4587803383"
categories:
  - Haskell
tags:
  - define functions
---
## 수학적 함수표기와 Haskell 함수표기의 차이점 {#toc_0}

| Mathematics | Haskell   |
| ----------- | --------- |
| f(x)        | f x       |
| f(x,y)      | f x y     |
| f(g(x))     | f (g x)   |
| f(x,g(y))   | f x (g y) |
| f(x)g(y)    | f x * g y |

## 조건 표현식으로 함수 정의하기 {#toc_2}

<div>
  <pre class="lang:haskell decode:true ">abs :: Int -&gt; Int
abs n = if n &gt;= 0 then n else -n</pre>
</div>

### 조건 표현식 중첩하기 {#toc_3}

<div>
  <pre class="lang:haskell decode:true">signum :: Int -&gt; Int
signum n = if n &lt; 0 then -1 else
            if n == 0 then 0 else 1</pre>
</div>

`주의` Haskell에서 `if` 조건 표현식은 항상 `else` 문이 있어야 한다.

## Guard를 사용하여 함수 정의하기 {#toc_4}

<div>
  <pre class="lang:haskell decode:true">abs n | n &gt;= 0    = n
      | otherwise = -n</pre>
</div>

<div>
  <pre class="lang:haskell decode:true">signum n | n &lt; 0     = -1
         | n == 0    = 0
         | otherwise = 1</pre>
</div>

아주 깔끔하다.

## 패턴매칭을 사용하여 함수 정의하기 {#toc_5}

<div>
  <pre class="lang:haskell decode:true">not :: Bool -&gt; Bool
not False = True
not True  = False</pre>
</div>

<div>
  <pre class="lang:haskell decode:true">(&&) :: Bool -&gt; Bool -&gt; Bool
True  && True       = True
True  && False      = False
False && True       = False
False && False      = False</pre>
</div>

좀 더 간단하게

<div>
  <pre class="lang:haskell decode:true">(&&) :: Bool -&gt; Bool -&gt; Bool
True && True = True
_    && _    = False</pre>
</div>

좀 더 성능 좋게, 첫번째 인자를 평가해서 False이면 두 번째 인자를 평가하지 않기 때문이다.

<div>
  <pre class="lang:haskell decode:true">(&&) :: Bool -&gt; Bool -&gt; Bool
True  && b = b
False && _ = False</pre>
</div>

## 함수 정의에 나타나는 리스트 패턴 {#toc_6}

  * `:` 은 cons라 부른다.
  * `[1,2,3,4]` 는 `1:(2:(3:(4:[])))` 를 의미한다.
  * `:`는 존재하는 리스트의 앞쪽에 요소를 삽입하는 연산자이다.
  * xs 처럼 s 가 붙은 표기를 리스트로 보는 관례가 있다.
  * (x:xs) 는 첫 요소가 x이고 나머지가 xs인 리스트이다.

<div>
  <pre class="lang:haskell decode:true">head :: [a] -&gt; a
head (x:_) = x

 * 리스트를 받아 첫 요소를 반환하는 함수</pre>
</div>

<div>
  <pre class="lang:haskell decode:true  ">tail :: [a] -&gt; a
tail (_::xs) = xs

 * 리스트를 받아 첫요소를 제외한 나머지 목록을 반환하는 함수</pre>
</div>